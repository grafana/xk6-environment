// Code generated by tygor; DO NOT EDIT.

// ˮsummaryˮ
package environment

import (
	"errors"
	"fmt"
	"github.com/dop251/goja"
	"go.k6.io/k6/js/modules"
	"time"
)

// k6Module represents k6 JavaScript extension module.
type k6Module struct {
	goModuleConstructor goModuleConstructor
}

// NewModuleInstance creates new per VU module instance.
func (m *k6Module) NewModuleInstance(vu modules.VU) modules.Instance {
	mi := new(k6ModuleInstance)
	adaptee := m.goModuleConstructor(vu)
	adapter := jsModuleFrom(adaptee)

	vm := vu.Runtime()

	dict := make(map[string]interface{})

	dict["Environment"] = vm.ToValue(newEnvironmentConstructor(adaptee.newEnvironment))

	mi.exports.Named = dict

	obj := adapter.defaultEnvironmentGetter(goja.FunctionCall{This: goja.Undefined()}, vm).ToObject(vm)

	mi.exports.Default = obj

	return mi
}

// register registers k6 JavaScript extension module.
func register(ctor goModuleConstructor) {
	m := new(k6Module)
	m.goModuleConstructor = ctor
	modules.Register("k6/x/environment", m)
}

// k6ModuleInstance represents per VU module instance.
type k6ModuleInstance struct {
	exports modules.Exports
}

// Exports returns exported symbols.
func (mi *k6ModuleInstance) Exports() modules.Exports {
	return mi.exports
}

// jsModule is the go binding for the JavaScript Module type.
//
// TSDoc:
// ˮsummaryˮ
type jsModule interface {
	// defaultEnvironmentGetter is the go getter binding for the JavaScript defaultEnvironment property.
	//
	// TSDoc:
	// Default Environment instance.
	defaultEnvironmentGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// jsModuleAdapter converts goModule to jsModule.
type jsModuleAdapter struct {
	adaptee goModule
}

var _ jsModule = (*jsModuleAdapter)(nil)

// defaultEnvironmentGetter is a jsModule property getter adapter method.
func (self *jsModuleAdapter) defaultEnvironmentGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.defaultEnvironmentGetter()
	if err != nil {
		panic(err)
	}

	return goEnvironmentToObject(v, vm)
}

// jsModuleFrom returns a jsModule based on a goModule.
func jsModuleFrom(adaptee goModule) jsModule {
	return &jsModuleAdapter{adaptee: adaptee}
}

// goModule is the go representation of the JavaScript Module type.
//
// TSDoc:
// ˮsummaryˮ
type goModule interface {
	// newEnvironment is the go factory method for the Environment type.
	newEnvironment(paramsArg interface{}) (goEnvironment, error)

	// defaultEnvironmentGetter is the go getter method for the defaultEnvironment property.
	//
	// TSDoc:
	// Default Environment instance.
	defaultEnvironmentGetter() (goEnvironment, error)
}

// goModuleConstructor creates new goModule instance.
type goModuleConstructor func(vu modules.VU) goModule

// jsEnvironment is the go binding for the JavaScript Environment type.
//
// TSDoc:
// This is the primary class of the environment extension.
type jsEnvironment interface {
	// initMethod is the go binding for the JavaScript init method.
	//
	// TSDoc:
	// init creates an Environment as defined in constructor.
	initMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// deleteMethod is the go binding for the JavaScript delete method.
	//
	// TSDoc:
	// delete removes an existing Environment.
	deleteMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// applyMethod is the go binding for the JavaScript apply method.
	//
	// TSDoc:
	// apply reads the contents of the file and applies them to the virtual cluster.
	applyMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// applySpecMethod is the go binding for the JavaScript applySpec method.
	//
	// TSDoc:
	// applySpec applies the spec to the virtual cluster.
	applySpecMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// waitMethod is the go binding for the JavaScript wait method.
	//
	// TSDoc:
	// `wait` method blocks execution of the test iteration until a certain condition
	// is reached or until a timeout. There are 3 major types of conditions now:
	//
	// 1. Wait until a given Kubernetes event.
	//
	// 2. Wait until a given `.status.conditions[]` reaches a given value.
	//
	// 3. Wait until a custom field in `.status` reaches a given value.
	waitMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// getNMethod is the go binding for the JavaScript getN method.
	//
	// TSDoc:
	// getN is a substitute for get(), hopefully temporary. See [tygor's](https://github.com/szkiba/tygor) roadmap about support for arrays.
	getNMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goEnvironment is the go representation of the JavaScript Environment type.
//
// TSDoc:
// This is the primary class of the environment extension.
type goEnvironment interface {
	// initMethod is the go representation of the init method.
	//
	// TSDoc:
	// init creates an Environment as defined in constructor.
	initMethod() (interface{}, error)

	// deleteMethod is the go representation of the delete method.
	//
	// TSDoc:
	// delete removes an existing Environment.
	deleteMethod() (interface{}, error)

	// applyMethod is the go representation of the apply method.
	//
	// TSDoc:
	// apply reads the contents of the file and applies them to the virtual cluster.
	applyMethod(fileArg string) (interface{}, error)

	// applySpecMethod is the go representation of the applySpec method.
	//
	// TSDoc:
	// applySpec applies the spec to the virtual cluster.
	applySpecMethod(specArg string) (interface{}, error)

	// waitMethod is the go representation of the wait method.
	//
	// TSDoc:
	// `wait` method blocks execution of the test iteration until a certain condition
	// is reached or until a timeout. There are 3 major types of conditions now:
	//
	// 1. Wait until a given Kubernetes event.
	//
	// 2. Wait until a given `.status.conditions[]` reaches a given value.
	//
	// 3. Wait until a custom field in `.status` reaches a given value.
	waitMethod(conditionArg interface{}, optsArg interface{}) (interface{}, error)

	// getNMethod is the go representation of the getN method.
	//
	// TSDoc:
	// getN is a substitute for get(), hopefully temporary. See [tygor's](https://github.com/szkiba/tygor) roadmap about support for arrays.
	getNMethod(typeArg string, optsArg interface{}) (float64, error)
}

// jsEnvironmentAdapter converts goEnvironment to jsEnvironment.
type jsEnvironmentAdapter struct {
	adaptee goEnvironment
}

var _ jsEnvironment = (*jsEnvironmentAdapter)(nil)

// initMethod is a jsEnvironment adapter method.
func (self *jsEnvironmentAdapter) initMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.initMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// deleteMethod is a jsEnvironment adapter method.
func (self *jsEnvironmentAdapter) deleteMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.deleteMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// applyMethod is a jsEnvironment adapter method.
func (self *jsEnvironmentAdapter) applyMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.applyMethod(call.Argument(0).String())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// applySpecMethod is a jsEnvironment adapter method.
func (self *jsEnvironmentAdapter) applySpecMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.applySpecMethod(call.Argument(0).String())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// waitMethod is a jsEnvironment adapter method.
func (self *jsEnvironmentAdapter) waitMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.waitMethod(call.Argument(0).Export(), call.Argument(1).Export())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// getNMethod is a jsEnvironment adapter method.
func (self *jsEnvironmentAdapter) getNMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.getNMethod(call.Argument(0).String(), call.Argument(1).Export())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// goEnvironmentAdapter converts goja Object to goEnvironment.
type goEnvironmentAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goEnvironment = (*goEnvironmentAdapter)(nil)

// initMethod is a init adapter method.
func (self *goEnvironmentAdapter) initMethod() (interface{}, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("init"))
	if !ok {
		return nil, fmt.Errorf("%w: init", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return nil, err
	}

	return res.Export(), nil
}

// deleteMethod is a delete adapter method.
func (self *goEnvironmentAdapter) deleteMethod() (interface{}, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("delete"))
	if !ok {
		return nil, fmt.Errorf("%w: delete", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return nil, err
	}

	return res.Export(), nil
}

// applyMethod is a apply adapter method.
func (self *goEnvironmentAdapter) applyMethod(fileArg string) (interface{}, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("apply"))
	if !ok {
		return nil, fmt.Errorf("%w: apply", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return nil, err
	}

	return res.Export(), nil
}

// applySpecMethod is a applySpec adapter method.
func (self *goEnvironmentAdapter) applySpecMethod(specArg string) (interface{}, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("applySpec"))
	if !ok {
		return nil, fmt.Errorf("%w: applySpec", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return nil, err
	}

	return res.Export(), nil
}

// waitMethod is a wait adapter method.
func (self *goEnvironmentAdapter) waitMethod(conditionArg interface{}, optsArg interface{}) (interface{}, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("wait"))
	if !ok {
		return nil, fmt.Errorf("%w: wait", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return nil, err
	}

	return res.Export(), nil
}

// getNMethod is a getN adapter method.
func (self *goEnvironmentAdapter) getNMethod(typeArg string, optsArg interface{}) (float64, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("getN"))
	if !ok {
		return 0, fmt.Errorf("%w: getN", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return 0, err
	}

	return res.ToFloat(), nil
}

// jsEnvironmentTo setup Environment JavaScript object from jsEnvironment.
func jsEnvironmentTo(src jsEnvironment, obj *goja.Object, vm *goja.Runtime) error {
	if err := obj.Set("init", src.initMethod); err != nil {
		return err
	}

	if err := obj.Set("delete", src.deleteMethod); err != nil {
		return err
	}

	if err := obj.Set("apply", src.applyMethod); err != nil {
		return err
	}

	if err := obj.Set("applySpec", src.applySpecMethod); err != nil {
		return err
	}

	if err := obj.Set("wait", src.waitMethod); err != nil {
		return err
	}

	return obj.Set("getN", src.getNMethod)
}

// jsEnvironmentFrom returns a jsEnvironment based on a goEnvironment.
func jsEnvironmentFrom(adaptee goEnvironment) jsEnvironment {
	return &jsEnvironmentAdapter{adaptee: adaptee}
}

// goEnvironmentFrom returns a goEnvironment from goja Object.
func goEnvironmentFrom(adaptee *goja.Object, vm *goja.Runtime) goEnvironment {
	return &goEnvironmentAdapter{adaptee: adaptee, vm: vm}
}

// goEnvironmentToObject returns a goja Object from goEnvironment.
func goEnvironmentToObject(v goEnvironment, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsEnvironmentTo(jsEnvironmentFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// goEnvironmentConstructor creates new goEnvironment instance.
type goEnvironmentConstructor func(paramsArg interface{}) (goEnvironment, error)

// newEnvironmentConstructor creates Environment JavaScript constructor.
func newEnvironmentConstructor(ctor goEnvironmentConstructor) func(call goja.ConstructorCall, vm *goja.Runtime) *goja.Object {
	return func(call goja.ConstructorCall, vm *goja.Runtime) *goja.Object {
		adaptee, err := ctor(call.Argument(0).Export())
		if err != nil {
			panic(err)
		}

		adapter := jsEnvironmentFrom(adaptee)

		if err := jsEnvironmentTo(adapter, call.This, vm); err != nil {
			panic(err)
		}

		return nil
	}
}
func goTimeFromDate(v goja.Value, vm *goja.Runtime) time.Time {
	getTime, ok := goja.AssertFunction(v.ToObject(vm).Get("getTime"))
	if !ok {
		panic(fmt.Errorf("%w: getTime", errors.ErrUnsupported))
	}

	ret, err := getTime(v)
	if err != nil {
		panic(err)
	}

	return time.UnixMilli(ret.ToInteger())
}

func jsDateFromTime(t time.Time, vm *goja.Runtime) goja.Value {
	d, err := vm.New(vm.Get("Date"), vm.ToValue(t.UnixMilli()))
	if err != nil {
		panic(err)
	}

	return d
}
